---
typora-root-url: ./
---

​                                                                 **面试**

 **1. java的跨平台原理**

​	应为java有自己的虚拟机在不同平台上运行java虚拟机使得接口统一，部通平台上jvm不同，java通过不同版本及不同位数的jvm来屏蔽不同的系统间的指令集的差异，对外提供统一的javaapi接口，

**2.java基础知识**

​      java中有8中数据类型 int 8位4个字节  boolean 1 位   char  2字节  byte 1字节  short 2字节  long  8字节  float 4字节  double 8字节

**3.面向对象的特征有哪些方面**

​     封装（高度自治的封闭个体，对外提供获取自己或改变自己的方法），继承（可以继承一个类的的同时改变其中的一些内容），多态（已用变量指向具体类型 父类已用指向子类对象），抽象（把现实生活中的共同特征对象抽象为类）

**4.基本类型与包装类型**

​     为什么要有包装类型 ？java是一个面向对象的语言而基本的数据类型部具备面向对象的特性 如

null->integer 0->int 在数据库中容易歧义

**5.“==”和equals方法有什么区别**

"=="用来判断两个变量之间的值是否相等，变量分为基本数据类型和引用数据类型，基本数据类型直接比较值，而引用数据类型比较的是地址值

“equals” 用来比较两个对象长得是否一样，判断两个对象的某些特征是否一样，实际上就是调用对象的equals方法，基本数据类型没有equals方法

**6.string 和stringbuilder，stringbuffer和stringbuilder的区别**

string 是内容不可变的字符串，底层是一个不可变的字符数组（final char[]），而stringbuilder和stringbuffer是内容可变的字符串，底层使用的可变的字符数组可用append方法改变，拼接字符串不能使用string进行拼接，要使用stringbuffer和stringbuilder     stringbuffer和stringbuilder的区别stringbuffer线程安全，效率低和stringbuilder线程不安全，效率高

**7.java中的集合**

​	java中的集合分为value和key-value(collection map)两种

​     存储值分为list和set 存储key-value为map

​	list是有序的可重复的

​	set是无序的部可重复的，根据equals和hashcode来判断，也就是如果宇哥对象要存储到set中必须要重写equals和hashcode方法

**8.list**

​	list常用的arraylist和linklist，区别和使用场景

​	arraylist底层使用的数组（具有索引查询特定的元素很快而插入和删除修改比较慢，因为数组在内存中是一块连续的内存，如果插入删除时需要移动内存），linklist底层使用链表（不要求内存是连续的，在当前元素中存放上一个和下一个元素的地址查询时需要从头部开始一个一个的找索引，查询效率低而插入时不需要移动内存，只需改变引用指向即可，所以插入或者删除的效率高）

arraylist使用在查询比较多，但是插入和删除比较少的情况，linklist相反

**9.hashMap和hashTable，currenthashmap的**区别

​	hashmap和hashtable都可以使用存储key-value的数据，hashmap是可以把null作为key或value的，而hashtable是不可以的，hashmap是线程不安全的，效率高，而hashtable是线程安全的，效率低

​	既想线程安全又想效率高？currenthashmap （把大的分成多个小的）通过把整个map分为N个segment（类似hashtable），可以提供相同的线程安全，但是效率提升N倍，默认提升16倍

**10.实现一个拷贝文件的工具使用自字节流是字符流**

​	纯文本用字符流，其他用（有声音图片的）字节流

**11.线程的几种实现方式，怎么启动？怎么区分？线程池？线程病发率**

​	方式1，通过继承Thread类实现一个线程    继承的扩展性不强，java只有单继承，如果一个类继承Thread就不能继承其他类了

​	方式2，通过实现Rannable接口实现一个线程

​	怎么启动？Thread thread =new Thread(继承了Thread的对象/实现了Runnable接口) Thread.start(启动线程的方法)  启动后执行的是run方法

​	怎么区分线程？在一个系统中有很多线程，每个线程都会打印日志，我想区分是哪个线程怎样标识？可以设置一个线程名称 thread.set("name") 是一种规范

**12.有没有使用过线程并发库？**

​	线程池的作用？限定线程的个数，不会导致由于线程过多导致系统运行缓慢或崩溃；线程池在开始不需要。后期会增加

**13.设计模式，常用的有哪些**？

​	设计模式就是经过前人无数次实践过程中可以反复使用解决特定问题的设计方法。

​	**常用的是**：单例模式  分为饱汉式（一出来就创建单实例）饥汉式（需要的时候才创建） 1.构造方法私有化，让除了自己类中能创建外，其他地方都不能创建     2.在自己的类中创建一个单实例  3.提供一个方法获取该实例对象

​	工厂模式：springIOC就是使用了工厂模式，对象的创建交给一个工厂去创建

​	代理模式：SpringAOP就是使用的动态代理

​	包装模式

**14.http get和post的区别？**

​	get 请求的参数会符在url之后（就是把数据放置在http协议头中），以？分割，多个参数用&连接；post提交：把提交的数据放置在http的包体中，因此get在地址栏能看到，post看不到；

​	传输数据大小get（数据有限），post（没有）；

​	安全性get（地址栏会显示） post（不显示）

**15.说下对servlet的理解？**

​	servlet是服务器端的程序，运行在服务器端主要用于交互式浏览和修改数据，生成动态web内容，httpServlet重写doGet和doPost方法，也可以重写service方法完成get post的请求

**16，servlet的生命周期**

​	它的生命周期由java.servlet接口的init，service和destroy方法来表达

​	servlet启动时，开始加载servlet生命周期开始。servlet被服务器实例化后，容器运行其init方法，请求到达时运行service方法，service方法自动请求对应的doxx方法，当服务器销毁实例时调用destroy方法

**17.jsp和servlet有哪些相同点和不同点，它们之间的联系是什么？**

​	所有的jsp文件都会被翻译为一个继承HttpServlet的类，也就是jsp最终也是一个servlet，这个servlet对外提供服务

​	不同点：jsp侧重于视图，而servlet主要用于控制逻辑

​	jsp中9个内置对象：

request，response,pagecontext,session,application,out,config,page,exception

​	jsp中4大作用域：

pageContext，request，session，application

​	jsp传值：request，session，application，cookie

**18.session和cookie的区别**

​	cookie在客户端记录用户信息，session是在服务端，但是session的实现依赖于cookie，sessionId存放在cookie中，单个cookie保存数据不能超过4k，一个站点最多20 个cookie，当客户端禁用cookie时，就采用cookie+数据库方式

**19.数据库**

​	非关系型数据库：redis，memcache,mongodb,hadoop等

关系型数据库的三泛式：

​	第一范式，是根据数据库表中的每一列都不可以分割的基本数据项，同一列中不能有多个值，即实体类中的某个属性不能有多个值或者不能有重复的属性，（列数据不可分割）

​	第二范式，数据库表中的每行必须可以被唯一区分，为实现区分通常为表加上一列，存储各个实例的唯一标识。（即主键）

​	第三范式，要求一个数据库表中不包含已在其他表中已包含的非主键字信息（外键）

反三范式：有的时候为了效率，可以设置重复字段 

**20.事务（ACID）**

​	原子性 ：表示事务操作不可分割，要么成功，要么失败

​        一致性：要么都成功，要么都失败，后面失败了要对前面的操作进行回滚 

​	 隔离性：一个事务开始后不能受其他事务干扰

 	持久性：表示事务开始了就不能终止可持久到硬盘

**21.mysql数据库的默认的最大连接数**

​	为什么需要最大连接数？特定服务器上的数据库只能支持一定数目的连接，数据库安装时都会有一个最大连接数100，我们一般都会设置最大连接时

**22.mysql分页和oracl分页**

​	mysql用limit进行，limit offset，size

​	oracl的分页有点记不住，使用了三层嵌套查询

**23.触发器**

​	触发器要有触发条件，触发器效率高

**24.存储过程**

**25.简单说下你对jdbc的理解**

​	java database connection java只定义接口，让数据厂商自己实现接口，对于我们而言，只需要导入对应厂商开发的实现即可，然后以接口方式进行调用（mysql+mysql驱动即mysql接口实现+jdbc）。

**26.jdbc中preparedStatement相比statement的好处**

​	1.preparedstatement是预编译的，比statement速度快，还能有效防止sql注入

​	2.代码的可读性和可维护性好

**27.写一个简单的jdbc的程序？**

​	“贾连欲执事”    加载驱动  获取连接（DriverManager.getconnection(url,user,pw )）  设置参数  执行  释放连接（释放连接要从小到大，放在finaly里）

**28.数据库连接池的作用？**

​	限定个数，节约系统资源，加快响应时间

**29.介绍 一下ajax？**

​	什么是ajax？（异步的javascript和xml）作用是什么？（数据异步交换，局部刷新数据）怎么实现？（ajaxXmlhttprequest对象，使用这个对象异步发送数据，获取响应，完成局部更新）应用场景？（登录场景，失败时跳转，注册时提示用户名是否存在，二级联动等）

**30.js和jquery？**

​	jQuery是一个js框架，封装了js的属性和方法，并且增强了js的功能，让用户使用起来更加便利，原来使用js时要处理兼容性问题，现在有jQuery封装了底层好多了，原生的js的dom和事件绑定非常麻烦。

**31.jquery的常用选择器？**

​	ID选择器，class选择器，标签选择器，通用选择器

**32.jquery中的ajax和原生js实现ajax有什么关系？**

​	jquery中的ajax也是通过原生的js封装的，如果采用原生的js实现ajax是麻烦的，即使我们不使用jquery也要封装对象的方法和属性。

**33.spring的核心**

​	spring是IOC和AOP的容器  IOC控制反转，我的service需要调用dao，service就需要创建dao，在使用spring之后，spring发现你的service依赖与dao就给你注入。核心原理：就是工厂模式（容器map）+反射+配置文件。

​	AOP：面向切面编程，核心原理：使用动态代理的方式在执行前后或出现异常做相关的逻辑，我们主要使用aop做 （1.事务处理，2.权限判断 3.日志）

**34.spring的事物的传播特性**

**35.spring解析**（<https://blog.csdn.net/java_lyvee/article/details/101793774>）

​	1.spring中的循环依赖怎解决的？spring中是默认单例支持循环的

​	2.怎么证明他默认他默认支持的？怎么关闭循环依赖？spring解决循环依赖的细节

依赖注入的功能---在初始化时完成，初始化时干的工作？

​	1.初始化bean--bean有一个初始化的过程-------spring bean的生命周期

​	2.spring的生命周期到底在哪个步骤完成的依赖注入？

​	3.spring bean的产生过程------------------bean是由什么产生来的

​		class-----beanDefinition----------object（bean）

  	4.spring的实例化流程 ：（1）先scan扫描类，把要创建的类扫描出来，进行一个for循环拿到扫描出来的类，但是他不知道要不要创建，所以它要进行解析，（2）创建了一个beandefinition类，然后把类的属性set进去（比如是不是懒加载，或者类的scope），解析完后，（3）把他放put到一个map中；（4）然后看看你是否对spring进行了扩展，如果要扩展要实现一个beanfactorypoatprocessor；（5）遍历map，将解析出来的类遍历出来在决定要不要new

**36.spring bean的作用域**

​	bean的作用域范围可以再scope属性中设置，默认情况下，spring只为每个在IOC容器中声明的bean创建一个都实例，整个容器范围内都能共享该实例，所有后续的getbean（）都返回唯一的bean实例，该作用域成为singleton，还有prototype域（每次调用getbean时会返回一个新实例调用）   

request域（每次HTTP请求回创建一个新的bean）  session域（在一个会话中共享一个bean）

**37.如何解决中文乱码问题？**

​	post请求中在charetfilter中设置encoding值，我满五年可以在web.xml中设置初始化参数

  <init-param>  

​	<param-name>encoding</param-name>

​        <param-value>utf-8</param-value>

<init-param> 

   <init-param>  

​	<param-name>foreencoding</param-name>

​        <param-value>true</param-value>

<init-param> 

针对get请求乱码问题最简单的就是修改tomcat的server.xml来修改urlencoding=utf-8

**38.Mybatis中当实体类中的属性名和表中的字段名部一样，怎么办？**

​	解决方案：

​	1.写sql语句时起别名

​	2.在mybatis的全局配置文件开启驼峰命名规则，在mybatis-config。xml中

​	3.在mapper的映射文件中使用resultMap来自定义映射规则

**39.linux系统常用服务类相关命令？**

​	1.service network status 查看网络状态

​	2.chkconfig --list列取服务 用来设置自启动 

**40.Redis持久化**
	rdb 节省空间，恢复快，fork一个子进程数据量大也很慢，满足条件才存储，

​	aof以日志方式，细粒度，增量备份，丢失数据概率低，数据是日志格式，站空间，恢复速度慢有读写存在一定性能压力，存在个别bug

**41.git常用操作**

​	第一次创建用户 git config --global user.name="用户名"     git config --global user.email=“邮箱”  只创建一次就够了

1.git status  查看当前状态 	  2.git add 文件名1 文件名2（可以添加一个或者多个）  添加到缓存区	     3.git .  添加当前目录到缓存区中

提交至版本库：git commit -m “注释内容”

查看版本：git log --pretty=online

回退操作：git reset --hard 提交编号

回到过去后要想在回到当前最新版本时，则需要指令区查看历史操作，已得到最新的commit id 使用指令 git reflog 查看版本号在通过 git reset --hard 版本号回到现在

**42.GitHub上两种常规使用方式**

​	1.基于http协议

​	a.创建空目录，名称就叫shop

​	b.使用clone指令克隆线上仓库到本地 语法：git clone +线上仓库地址 

​	c.在仓库上做对应的操作（提交暂存区，提交本地仓库，提交线上仓库，拉取线上仓库）

​		提交到线上仓库的指令：git push 在首次往线上仓库提交时出现403致命错误，原因是不是谁都能提交的必须鉴权，需要修改“./git/config”文件内容

​	d.拉取线上最新版本 git pull  上班时要经常拉取

​	2.基于ssh协议的

​		该方式与前面的HTTPS方式相比，只是影响GitHub对于用户的身份鉴权的方式，对其他没影响。

生成公私钥对指令（需要自行安装openssh） ssh-keygen-t rsa -C "注册的邮箱"

​	步骤：a.生成客户端公私钥文件  b.将文件上传到GitHub

  	 **分支指令**

​	1.查看分支：git branch

​	2.创建分支：git branch 分支名

​	3.切换分支：git checkout 分支名

​	4.删除分支：git branch -d 分支名

​	5.合并分支：git merge 被合并的分支名

**43.冲突的产生与解决**

​	同事早我下班后修改了线上代码，此时我本地仓库内容与线上不一致，第二天上班后没拉取代码，直接修改了本地仓库的内容，然后下班提交代码产生冲突。

​	解决冲突：当执行git pull时显示已经合并。打开冲突文件，解决冲突。

​	解决方法：需要和同事（谁提交的，看代码如何保留，将改好的再次提交即可）

​	如果都保留包标记删除后提交即可，如果不想保留谁的删除提交即可 

解决乱码问题可在bash窗口下依次执行：

git config  core.quotepath off

git config  --unset i18n.logoutputencoding

git config  --unset i18n.commitencoding

忽略目录：在当前目录下创建一个./gitignore文件夹，在里面写上要忽略提交的文件名称

**44.并发编程与高并发**

​	多个线程操作同一个资源

​	线程的生命周期：1.新建    2.就绪    3.运行     4.阻塞      5.死亡	

**45.常用的设计模式？**

​	1.单例模式   <https://www.cnblogs.com/songyoulian/p/10029785.html>

​	2.工厂模式  <https://www.cnblogs.com/songyoulian/p/10053074.html>

​	3.装饰模式：又叫包装模式，通过对客户端透明的方式来扩展对象的功能，是继承关系的一种替换，符合开闭模式；在不改变原有对象的基础之上，将功能附加到对象上。提供了比继承更有弹性的替代方案（扩展原有对象功能）

使用场景：

1. 扩展一个类的功能或者给一个类添加附加职责
2. 给一个对象动态的添加功能，或动态撤销功能。

**46.有关JVM相关**？

​	![icon](/assert/1582772736336.png)

​	实例变量放在堆内存中；静态变量+常量（private，static，final，string）+类信息+运行时常量存在方法区    **栈管运行  ，堆管存储**  **垃圾回收只发生在堆中**   **jvm优化主要是优化堆**

​	基本类型的变量和对象的引用变量都是在函数的栈内存中分配，栈中部存在垃圾回收问题

 ![icon](/assert/1582772943186.png)

当对象被new时发生在新生区的伊甸园区；

养老区：一般是数据库连接池这种池类对象在这；

永久区：没有垃圾回收用于 存放运行环境所必需的的类信息，关闭jvm才释放内存 java7叫做永久代，java8叫做元空间

![icon](/assert/1582774755868.png

​		![icon](/assert/1582775750485.png)

![icon](/assert/1582776625729.png)

![icon](/assert/1582776717992.png)

永久代就是方法区



![icon](/assert/1582778144272.png)

GC是什么？

​	频繁收集young区（普通GC,用到的算法是复制算法（coping）不会产生内存碎片，就是有点浪费空间）； 较少收集Old区(全局GC，一般是由标记清除或者是标记清除与标记整理的混合实现)； 基本不动perm区

**47.索引的数据结构？**

   数据结构分为：**二叉树**：（key（查找的值）-value（磁盘地址）结构），当数据出现单边增长的时候在用二叉树查找不太合适，	

​     **红黑树** ：如果出现单边增长的话他会自平衡，但是如果存储大数据量的话它的树的高度会很大，导致磁盘IO会很频繁

![58288240418](/../../../ADMINI~1/AppData/Local/Temp/1582882404182.png)   

​      **hash表**  只要走了hash不管你的表的数据有多大，通过hash运算只需要一次磁盘io就能找到数据地址，但是如果是范围查找，hash算法就不行了

​     **b-tree**（mysql底层用的其实是b+tree，应为b-tree不能解决范围查找，虽然解决了红黑树树高的问题）  叶节点具有相同的深度，叶节点的指针为空，节点中的数据索引从左到右递增排列

​     **b+tree**：非叶子节点不存储data，只存储索引，可以放更多的索引，叶子节点不存储指针，顺序访问指针，提高区间访问的性能（树的高度为3时就可存储2千万条数据）

**48.存储引擎**

​	存储引擎到表级别常用的Innodb，MYSIAM

​	如果是myisam存储引擎的话在mysql的安装文件目录下的data文件夹下一个实例下边有三个文件分别为：

​        .frm		存储表结构相关的信息

​	.MYD	存储的是表结构中的所有的数据行信息

​	.MYI	存储的是表的索引

如果存储引擎是innodb的话有两个文件：

​	.frm:

​	.ibd:

​	什么是聚集索引？ 叶节点包含了完整的数据记录（把所引元素和数据元素聚集到一起）

​		innodb的主键索引其实就是聚集索引 myisam就是非聚集所引

​	为什么innodb表必须要有主键，并且推荐使用整型的自增所引（应为效率高，节省磁盘空间）？

​	     InnoDB引擎表是基于B+树的索引组织表(IOT)；每个表都需要有一个聚集索引(clustered index) 数据都是由b+tree来维护的，所以要有主键索引

**49.联合索引的底层存储结构长什么样？**

​	工作中常用，

**50.mysql常用的命令？**

看你的mysql现在已提供什么存储引擎:  show engines;

看你的mysql当前默认的存储引擎:show variables like '%storage_engine%';

   7种表的join：

建表：	

```sql
CREATE TABLE `tbl_dept` (
 `id` INT(11) NOT NULL AUTO_INCREMENT,
 `deptName` VARCHAR(30) DEFAULT NULL,
 `locAdd` VARCHAR(40) DEFAULT NULL,
 PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
 
CREATE TABLE `tbl_emp` (
 `id` INT(11) NOT NULL AUTO_INCREMENT,
 `name` VARCHAR(20) DEFAULT NULL,
 `deptId` INT(11) DEFAULT NULL,
 PRIMARY KEY (`id`),
 KEY `fk_dept_id` (`deptId`)
 #CONSTRAINT `fk_dept_id` FOREIGN KEY (`deptId`) REFERENCES `tbl_dept` (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
 
 
 
INSERT INTO tbl_dept(deptName,locAdd) VALUES('RD',11);
INSERT INTO tbl_dept(deptName,locAdd) VALUES('HR',12);
INSERT INTO tbl_dept(deptName,locAdd) VALUES('MK',13);
INSERT INTO tbl_dept(deptName,locAdd) VALUES('MIS',14);
INSERT INTO tbl_dept(deptName,locAdd) VALUES('FD',15);
 
 
INSERT INTO tbl_emp(NAME,deptId) VALUES('z3',1);
INSERT INTO tbl_emp(NAME,deptId) VALUES('z4',1);
INSERT INTO tbl_emp(NAME,deptId) VALUES('z5',1);
 
INSERT INTO tbl_emp(NAME,deptId) VALUES('w5',2);
INSERT INTO tbl_emp(NAME,deptId) VALUES('w6',2);
 
INSERT INTO tbl_emp(NAME,deptId) VALUES('s7',3);
 
INSERT INTO tbl_emp(NAME,deptId) VALUES('s8',4);
 
INSERT INTO tbl_emp(NAME,deptId) VALUES('s9',51);

```

7种查询：

```sql
1 A、B两表共有
 select * from tbl_emp a inner join tbl_dept b on a.deptId = b.id;
 
2 A、B两表共有+A的独有
 select * from tbl_emp a left join tbl_dept b on a.deptId = b.id;
 
3 A、B两表共有+B的独有
 select * from tbl_emp a right join tbl_dept b on a.deptId = b.id;
 
4 A的独有 
select * from tbl_emp a left join tbl_dept b on a.deptId = b.id where b.id is null; 
 
5 B的独有
 select * from tbl_emp a right join tbl_dept b on a.deptId = b.id where a.deptId is null; #B的独有
 
6 AB全有
#MySQL Full Join的实现 因为MySQL不支持FULL JOIN,下面是替代方法
 #left join + union(可去除重复数据)+ right join
SELECT * FROM tbl_emp A LEFT JOIN tbl_dept B ON A.deptId = B.id
UNION
SELECT * FROM tbl_emp A RIGHT JOIN tbl_dept B ON A.deptId = B.id
 
7 A的独有+B的独有
SELECT * FROM tbl_emp A LEFT JOIN tbl_dept B ON A.deptId = B.id WHERE B.`id` IS NULL
UNION
SELECT * FROM tbl_emp A RIGHT JOIN tbl_dept B ON A.deptId = B.id WHERE A.`deptId` IS NULL;

```

索引的创建删除语句

```sql
有四种方式来添加数据表的索引：
ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。
 
ALTER TABLE tbl_name ADD UNIQUE index_name (column_list): 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。
 
ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引，索引值可出现多次。
查看索引：
SHOW INDEX FROM TABLENAME \G
删除索引：
DROP INDEX[INDEXNAME] ON MYTABLE

查看sql详情
Explain + SQL语句
```

sql查询使用的类型：system > const > eq_ref > ref > range > index > all > all 一般能达到range级别最好能到ref级别

**51.权限认证shiro框架**

​	shiro提供了认证 授权  加密和会话管理等功能。

​	shiro是以过滤器的方式对访问规则进行控制，并且内置一系列过滤器 。大致分为认证过滤器和授权过滤器。

​	认证相关的有：anon(不认证也可以访问)  authbasic ，authc（必须认证才可以访问），user。

​	授权相关：perms（指定资源需要哪些权限才可以访问），roles，ssl，rest，port

spring整合shiro

​	spring提供一个简单的过滤器的处理方案，他将集体的操作交给内部filter对象delegate去处理，而这个delegate通过spring的IOC容器获取，这里采用spring的factorybean获取，虽然支配了一个filter，但是他并没有做实际的工作，而是交给spring容器中的为bean的名字的shirofilter类，即shirofactorybean，shiro过滤器工厂bean相当于间接地加载了9个内置过滤器

![58303311286](/../../../ADMINI~1/AppData/Local/Temp/1583033112867.png)

登录认证流程：1.创建令牌（对用户名和密码进行封装）  2.获取subject（主题应用程序与shiro交互的入口部分）    3.执行认证

自定义relam ：真正实现登录校验的人，shiro只是去调用它 。

shiro的三个核心组件：subject（主题）    SecurityManger（安全管理器）    Relam(数据源)。

**52.springsecurity？**

​	spring security 的核心功能主要包括：认证 （你是谁） 授权 （你能干什么） 	攻击防护 （防止伪造身份）

​	其核心就是一组过滤器链，项目启动后将会自动配置。最核心的就是 Basic Authentication Filter 用来认证用户的身份，一个在spring security中一种过滤器处理一种认证方式。

SecurityContextHolder，SecurityContext，Authentication是Spring Security的基础对象。

​	1. SecurityContextHolder：存储当前的SecurityContext，即认证用户的上下文信息，内部使用ThreadLocal。

​	2. SecurityContext：持有Authentication对象和其他可能需要的信息

​	3. UserDetails：从Authentication中获取的对象，代表当前用户的具体信息

UserDetailsService：获取UserDetails的逻辑，一般封装了查询用户的逻辑，内部只有一个方法：

 UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;

​	4.GrantedAuthority：当前用户获取到的授权信息。

案例：配置SpringSecurity的安全信息

```java
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    // @formatter:off
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .authorizeRequests()
                    .antMatchers("/css/**", "/index").permitAll()
                    
                    // 只有USER权限的角色才能访问/user/接口
                    .antMatchers("/user/**").hasRole("USER")
                    .and()
                .formLogin().loginPage("/login").failureUrl("/login-error");
    }

//  @Autowired
//  public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
//      auth
//          .inMemoryAuthentication()
//              .withUser(User.withDefaultPasswordEncoder().username("user").password("password").roles("USER"));
//  }
    // @formatter:on

    // 密码明文
    @Bean
    public PasswordEncoder passwordEncoder() {
        PasswordEncoder encoder = NoOpPasswordEncoder.getInstance();
        return encoder;
    }


  // 获取用户的来源
    @Bean
    public UserDetailsService userDetailsService(){
        UserDetailsService userDetailsService = new UserDetailsService(){

            @Override
            public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
                if (StringUtils.isEmpty(username) || !"admin".equalsIgnoreCase(username)){
                    return null;
                }

                HashSet<GrantedAuthority> hashSet = new HashSet<>();
                // 内部检验权限，要以ROLE为前缀
                hashSet.add(new  SimpleGrantedAuthority("ROLE_USER") );
                User user = new User("admin","test",hashSet);

                return user;
            }
        };
        return userDetailsService;
    }
}
```

 **53.存储过程与存储函数区别？**

​	（1）存储函数的限制比较多,例如不能用临时表,只能用表变量,而存储过程的限制较少，存储过程的实现功能要复杂些,而函数的实现功能针对性比较强。

　　（2）返回值不同。存储函数必须有返回值,且仅返回一个结果值；存储过程可以没有返回值,但是能返回结果集(out,inout)。

　　（3）调用时的不同。存储函数嵌入在SQL中使用,可以在select 存储函数名(变量值)；存储过程通过call语句调用 call 存储过程名。

　　（4）参数的不同。存储函数的参数类型类似于IN参数，没有类似于OUT和INOUT的参数。存储过程的参数类型有三种，IN、out和INOUT：

　　　　a. in：数据只是从外部传入内部使用(值传递),可以是数值也可以是变量

　　　　b. out：只允许过程内部使用(不用外部数据),给外部使用的(引用传递:外部的数据会被先清空才会进入到内部),只能是变量

　　　　c. inout：外部可以在内部使用,内部修改的也可以给外部使用,典型的引用 传递,只能传递变量。

**a.存储过程：**

​	

```sql
CREATE [OR REPLACE] PROCEDURE procedure_name[(parameter_name in|out|in out parameter_type, [, ...])]
{IS | AS}
  [columnName1 tableName.columnName1%type;
   columnName2 tableName.columnName2%type;
   ...
  ]
BEGIN
  < procedure_body >
END;
 
-- 语法说明：
-- ① 用[]包含的内容为可有可无，根据实际情况而定；
-- ② procedure_name：存储过程名称；
-- ③ parameter_name：参数名称；
-- ④ 参数模式：
--   in: 是参数的默认模式，这种模式就是在程序运行的时候已经具有值，在程序体中值不会改变；即，可以传入参数；
--   out：该模式定义的参数只能在过程体内部赋值，标识该参数可以将某个值传递回调用它的过程；即，可以返回值；
--   in out：表示该参数可以向过程中传递值，也可以将某个值传出去；即，既可以传入参数，也可以返回值；
-- ⑤ parameter_type：参数数据类型；
-- ⑥ is、as：在存储过程中，两者没有任何区别；但是在视图中只能用as，在游标中只能用is；
-- ⑦ procedure_body：PL/SQL子程序体；即该存储过程要执行的操作内容；
-- ⑧ 创建存储过程时，可以在is或者as后面添加对类型或变量的说明；

```

实例：创建添加员工信息的存储过程：

```sql
create or replace procedure addEmployee(eNo in out number, uName in out varchar2, dNo in out number, sal in out number, com in out number)
as
  empNo emp.empNo%type;
  usernName emp.username%type;
  deptNo emp.deptno%type;
  salary emp.salary%type;
  comm emp.comm%type;
begin
  insert into emp(empNo, username, deptNo, salary, comm)values(eNo, uName, dNo, sal, com);
end;
```

  PL/SQL调用存储过程：

```sql
declare
  empNo emp.empno%type := 7777;
  username emp.username%type := 'Hellen';
  deptNo emp.deptno%type := 10;
  salary emp.salary%type := 3800;
  comm emp.comm%type := 700;
begin
  addEmployee(empNo, username, deptno, salary, comm);
end;
```

**b.存储函数：**

创建语法：

```sql
CREATE [OR REPLACE] FUNCTION function_name[(parameter_name in parameter_type, [, ...])]
    RETURN returnValType
{IS | AS}
  [variable1 type;
   variable2 type;
   ...
  ]
BEGIN
  < procedure_body >
END;
 
-- 语法说明：
-- ① 用[]包含的内容为可有可无，根据实际情况而定；
-- ② function_name：存储函数名称；
-- ③ parameter_name：参数名称；
-- ④ in: 参数模式，存储函数只有in模式；
-- ⑤ parameter_type：参数数据类型；
-- ⑥ returnValType：函数返回值数据类型；
-- ⑦ is、as：在存储过程中，两者没有任何区别；但是在视图中只能用as，在游标中只能用is；
-- ⑧ variable、type：分别用于声明函数在执行过程中所需要的变量名称和数据类型； 
-- ⑨ procedure_body：PL/SQL子程序体；即该存储函数要执行的操作内容；
-- ⑩ 创建存储过程时，可以在is或者as后面添加对类型或变量的说明；
```

 实例：创建为员工加薪的存储函数

```sql
create or replace FUNCTION addSalary(eNo in number, addVal in number)
  RETURN number
AS
  pNo number;         -- 定义变量保存员工编号
  pName varchar2(30); -- 定义变量保存员工用户名
  pDeptNo number;     -- 定义变量保存员工部门编号
  pSal number;        -- 定义变量保存员工的工资
  pComm number;       -- 定义变量保存员工的奖金
  pTotal number;      -- 定义变量保存员工的总收入
  newSalary number;   -- 定义变量保存加薪后的工资
  newComm number;     -- 定义变量保存加薪后的奖金
BEGIN
  SELECT empNo, username, deptNo, salary, comm INTO pNo, pName, pDeptNo, pSal, pComm FROM EMP WHERE empNo=eNo;
  pTotal := (pSal+pComm)*12;
  DBMS_OUTPUT.PUT_LINE('员工'||pName||'：初始工资为='||pSal||'；初始奖金为='||pComm||'；初始年薪为='||pTotal);
 
  newSalary := pSal+pSal*addVal;
  newComm := newSalary*0.12;
  UPDATE EMP SET username=pName, deptNo=pDeptNo, salary=newSalary, comm=newComm WHERE empNo=pNo;
  RETURN newSalary;
END;
```

 PL/SQL调用存储函数，为编号为"2222"的员工加薪30%：

```sql
declare
  a number;        -- 定义变量，接受存储函数返回值
begin
  a := addSalary(1111, 0.3);    -- 调用存储函数
  DBMS_OUTPUT.put_line(a);      -- 打印存储函数返回值
end;
```

**54.Docker相关**

**docker镜像**：Docker镜像是由文件系统叠加而成（是一种文件的存储形式）。最底端是一个文件引导系统，即bootfs，这很像典型的Linux/Unix的引导文件系统。

一些常用命令：

列出docker下的所有镜像：docker images

 搜索镜像： docker search 镜像名称

 拉取镜像：docker pull centos:7   

  删除镜像： docker rmi $IMAGE_ID：删除指定镜像

 docker rmi `docker images -q`：删除所有镜像

**docker容器操作：**

看正在运行容器：docker ps

查看停止的容：docker ps -f status=exited

创建容器命令：docker run

  -i：表示运行容器

  -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。

 --name :为创建的容器命名。

-v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。

  -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。

  -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个－p做多个端口映射

实例：创建一个交互式容器并取名为mycentos

docker run -it --name=mycentos centos:7 /bin/bash

创建一个守护式容器：如果对于一个需要长期运行的容器来说，我们可以创建一个守护式容器。

docker run -di  --name=mycentos2 centos:7

登录守护式容器方式：docker exec -it container_name (或者container_id)  /bin/bash（exit退出时，容器不会停止）

停止正在运行的容器：docker stop 容器名/id.

启动已运行过的容器：docker start $CONTAINER_NAME/ID

**a.**文件拷贝：如果我们需要将文件拷贝到容器内可以使用cp命令:   docker cp 需要拷贝的文件或目录 容器名称:容器目录

也可以将文件从容器内拷贝出来: docker cp 容器名称:容器目录 需要拷贝的文件或目录

**b.**目录挂载：

创建容器 添加-v参数 后边为   宿主机目录:容器目录

docker run -di -v  /usr/local/myhtml:/usr/local/myhtml --name=mycentos2 centos:7  挂载多级目录时我们需要添加参数  --privileged=true

查看容器地址：docker inspect mycentos

删除容器：l  docker rm $CONTAINER_ID/NAME

**c.**迁移与备份：

​	容器保存为镜像：docker commit pinyougou_nginx（容器名字） mynginx（新的镜像名字）

此镜像的内容就是你当前容器的内容，接下来你可以用此镜像再次运行新的容器。

​	镜像备份：docker  save -o mynginx.tar mynginx        -o 输出到的文件

​	镜像恢复与迁移：docker load -i mynginx.tar    -i 输入的文件

容器和镜像可以互相转换。

**55.vue.js相关**  https://cn.vue.js.org

​	vue.js的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进dom的系统：

1.模板语法：

​	（1）插值

​		a.文本{{}}   b.如果想渲染纯HTML标签内容用指令v-html  防止一些攻击。

​	v-show=“属性” 控制节点是否显示   在dom中还存在

​	v-if=“属性”   如果为true 就创建节点，否则就删除节点（dom中就没了）

​	v-for=“（data,index或key） in或of datalist” 循环遍历即可拿到key值和索引值

​	![icon](/assert/1.png)

过滤方法(filter)：     indexof方法：“abc”.indexof("a") 判断a是否在“abc”中，在的话返回0，否则返回-1

```html
var arr=[1,2,3,4,5]
var newlist=arr.filter(item=>{
	return item>3
})
```

事件修饰符  阻止事件冒泡：@click.stop   @click.prevent="具体方法"  阻止默认事件

双向绑定事件：v-model.lazy 指令当失去焦点时触发，节省资源  v-model.number只绑定数字

 v-model.trim 去除空格

**vue组件**：

1.axios与fetch实现数据请求

fetch:	fetch("url").then(res=>res.json()).then(res=>consle.log(res));

axios:    axios.get().then(res=>{console.log(res.data(自动包装data属性))}).catch(err=>{console.log(err)})

2.计算属性

计算属性其实是在一个computed下定义的方法函数，使用时像一个属性一样去使用,计算属性性能高，它能缓存

![icon](/assert/2.png)

3.虚拟dom与diff算法key的作用

​	虚拟dom能提高性能，因为它能够最大程度得保证组件，节点的可复用性，减少对dom的频繁操作

4.组件化开发：

定义全局组件：vue.component("组件名"，{template:}),可以在任何地方使用。

定义局部组件：components:{组件名:{tempalte:}}   在谁的内部定义谁能使用。